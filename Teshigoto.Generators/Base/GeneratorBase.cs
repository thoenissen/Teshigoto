using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;

using Teshigoto.Annotation;
using Teshigoto.Generators.Core;
using Teshigoto.Generators.Core.Extensions;
using Teshigoto.Generators.Data;
using Teshigoto.Generators.Enumerations;
using Teshigoto.Generators.Equable;

namespace Teshigoto.Generators.Base;

/// <summary>
/// Base class for generating implementations
/// </summary>
public class GeneratorBase
{
    #region Fields

    /// <summary>
    /// Size of the indention
    /// </summary>
    private const int IndentionSize = 4;

    /// <summary>
    /// <see cref="GeneratedCodeAttribute"/> for the generated code
    /// </summary>
    private static readonly string _generateCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{Assembly.GetExecutingAssembly().GetName().Name}\", \"{Assembly.GetExecutingAssembly().GetName().Version}\")]";

    /// <summary>
    /// Buffer for the generated code
    /// </summary>
    private StringWriter _buffer;

    /// <summary>
    /// Writer for the generated code
    /// </summary>
    private IndentedTextWriter _writer;

    #endregion // Fields

    #region Constructor

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="metaData">Meta information</param>
    private protected GeneratorBase(CompilationMetaData metaData)
    {
        MetaData = metaData;
    }

    #endregion // Constructor

    #region Properties

    /// <summary>
    /// Meta information about the current compilation
    /// </summary>
    private protected CompilationMetaData MetaData { get; }

    /// <summary>
    /// Symbol to generate the implementation for
    /// </summary>
    protected ITypeSymbol Symbol { get; private set; }

    /// <summary>
    /// Fully qualified name of the symbol
    /// </summary>
    protected string SymbolName { get; private set; }

    #endregion // Properties

    #region Methods

    /// <summary>
    /// Initialize the generator
    /// </summary>
    /// <param name="symbol">Symbol</param>
    protected virtual void Initialize(ITypeSymbol symbol)
    {
        Symbol = symbol;
        SymbolName = Symbol.ToFullQualifiedDisplayString();

        _buffer = new StringWriter(new StringBuilder(4096));
        _writer = new IndentedTextWriter(_buffer, " ");

        WriteLine("// <auto-generated>");
        WriteLine("//     This code was generated by Teshigoto.Generators.");
        WriteLine($"//     Version: {Assembly.GetExecutingAssembly().GetName().Version}");
        WriteLine("//");
        WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
        WriteLine("// </auto-generated>");
        WriteLine();
        WriteLine("#nullable enable");
        WriteLine();
    }

    /// <summary>
    /// Write namespace
    /// </summary>
    protected void WriteOpenNamespace()
    {
        foreach (var symbol in SymbolWalker.ContainingNamespaceAndTypes(Symbol)
                                           .Reverse())
        {
            if (symbol is INamespaceSymbol namespaceSymbol)
            {
                WriteNamespace(namespaceSymbol);
            }
            else
            {
                break;
            }
        }

        WriteLine();
    }

    /// <summary>
    /// Write parent types
    /// </summary>
    protected void WriteOpenParentTypes()
    {
        foreach (var symbol in SymbolWalker.ContainingNamespaceAndTypes(Symbol)
                                           .Where(obj => obj is not INamespaceSymbol)
                                           .Reverse())
        {
            WriteParentSymbol(symbol);
        }

        WriteDeclaredAccessibility(Symbol.DeclaredAccessibility);
        WriteParentSymbol(Symbol);
    }

    /// <summary>
    /// Write the file-scoped namespace
    /// </summary>
    /// <param name="symbol">Symbol of the namespace</param>
    protected void WriteNamespace(INamespaceSymbol symbol)
    {
        var namespaceName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));

        if (string.IsNullOrEmpty(namespaceName) == false)
        {
            WriteLine($"namespace {namespaceName};");
        }
    }

    /// <summary>
    /// Write a parent type
    /// </summary>
    /// <param name="symbol">Symbol of the parent type</param>
    protected void WriteParentSymbol(ISymbol symbol)
    {
        var typeDeclarationSyntax = symbol.DeclaringSyntaxReferences
                                          .Select(x => x.GetSyntax())
                                          .OfType<TypeDeclarationSyntax>()
                                          .First();

        var keyword = typeDeclarationSyntax.Kind() switch
        {
            SyntaxKind.ClassDeclaration => "class",
            SyntaxKind.RecordDeclaration => "record",
            SyntaxKind.RecordStructDeclaration => "record struct",
            SyntaxKind.StructDeclaration => "struct",
            var unknownKind => throw new ArgumentOutOfRangeException($"Syntax kind {unknownKind} not supported")
        };

        var typeName = symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        WriteLine($"partial {keyword} {typeName}");
        WriteOpenBracket();
    }

    /// <summary>
    /// Write all missing closing brackets
    /// </summary>
    protected void WriteCloseNamespaceAndParentType()
    {
        while (_writer.Indent > 0)
        {
            WriteCloseBracket();

            if (_writer.Indent > 0)
            {
                _writer.WriteLine();
            }
        }
    }

    /// <summary>
    /// Write the <see cref="GeneratedCodeAttribute"/>
    /// </summary>
    protected void WriteGeneratedCodeAttribute()
    {
        WriteLine(_generateCodeAttribute);
    }

    /// <summary>
    /// Writes the declared accessibility
    /// </summary>
    /// <param name="accessibility">Accessibility</param>
    protected void WriteDeclaredAccessibility(Accessibility accessibility)
    {
        var accessibilityString = accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.Private => "private",
            _ => throw new ArgumentOutOfRangeException($"Accessibility {accessibility} not supported")
        };

        Write(accessibilityString);
        Write(" ");
    }

    /// <summary>
    /// Write a characters (without line break) to the generated code
    /// </summary>
    /// <param name="characters">Characters</param>
    protected void Write(string characters)
    {
        _writer.Write(characters);
    }

    /// <summary>
    /// Writes an empty line to the generated code
    /// </summary>
    protected void WriteLine()
    {
        var currentIndent = _writer.Indent;

        _writer.Indent = 0;
        _writer.WriteLine();
        _writer.Indent = currentIndent;
    }

    /// <summary>
    /// Writes a line to the generated code
    /// </summary>
    /// <param name="line">Line</param>
    protected void WriteLine(string line)
    {
        _writer.WriteLine(line);
    }

    /// <summary>
    /// Decrements the indention
    /// </summary>
    /// <param name="characters">Characters to decrement</param>
    protected void DecrementIndention(int? characters = null)
    {
        _writer.Indent -= characters ?? IndentionSize;
    }

    /// <summary>
    /// Increments the indention
    /// </summary>
    /// <param name="characters">Characters to increment</param>
    protected void IncrementIndention(int? characters = null)
    {
        _writer.Indent += characters ?? IndentionSize;
    }

    /// <summary>
    /// Write opening bracket (<c>'{'</c>) and closing bracket (<c>'}'</c>)
    /// </summary>
    /// <returns><see cref="IDisposable"/> object to mark the end</returns>
    protected IDisposable WriteBracket()
    {
        return new GroupWrite(WriteOpenBracket, WriteCloseBracket);
    }

    /// <summary>
    /// Write an opening bracket (<c>'{'</c>) and increase the indention
    /// </summary>
    protected void WriteOpenBracket()
    {
        WriteLine("{");

        _writer.Indent += IndentionSize;
    }

    /// <summary>
    /// Write a closing bracket (<c>'}'</c>) and decrease the indention
    /// </summary>
    protected void WriteCloseBracket()
    {
        _writer.Indent -= IndentionSize;

        WriteLine("}");
    }

    /// <summary>
    /// Write a region start and end
    /// </summary>
    /// <param name="name">Name</param>
    /// <returns><see cref="IDisposable"/> object to mark the end</returns>
    protected IDisposable WriteRegion(string name)
    {
        return WriteGroup(WriteStartRegion, WriteEndRegion, name);
    }

    /// <summary>
    /// Write a region start (#region)
    /// </summary>
    /// <param name="name">Name</param>
    protected void WriteStartRegion(string name)
    {
        Write("#region ");
        WriteLine(name);
        WriteLine();
    }

    /// <summary>
    /// Write a region end (#endregion)
    /// </summary>
    /// <param name="name">Name</param>
    protected void WriteEndRegion(string name)
    {
        var builder = _buffer.GetStringBuilder();

        if ((builder[builder.Length - 1] != '\n'
             || builder[builder.Length - 2] != '\n')
            && (builder[builder.Length - 1] != '\n'
                || builder[builder.Length - 2] != '\r'
                || builder[builder.Length - 3] != '\n'
                || builder[builder.Length - 4] != '\r'))
        {
            WriteLine();
        }

        Write("#endregion // ");
        WriteLine(name);
    }

    /// <summary>
    /// Write a summary xml documentation
    /// </summary>
    /// <param name="summary">Summary</param>
    protected void WriteXmlDocSummary(string summary)
    {
        WriteLine("/// <summary>");
        Write("/// ");
        WriteLine(summary);
        WriteLine("/// </summary>");
    }

    /// <summary>
    /// Write parameter xml documentation
    /// </summary>
    /// <param name="name">Name</param>
    /// <param name="value">Value</param>
    protected void WriteXmlDocParameter(string name, string value)
    {
        Write("/// <param name=\"");
        Write(name);
        Write("\">");
        Write(value);
        WriteLine("</param>");
    }

    /// <summary>
    /// Write group with start and ending
    /// </summary>
    /// <param name="start">Start</param>
    /// <param name="end">End</param>
    /// <returns><see cref="IDisposable"/> object to mark the end</returns>
    protected IDisposable WriteGroup(Action start, Action end)
    {
        return new GroupWrite(start, end);
    }

    /// <summary>
    /// Write group with start and ending
    /// </summary>
    /// <param name="start">Start</param>
    /// <param name="end">End</param>
    /// <param name="value">Value</param>
    /// <returns><see cref="IDisposable"/> object to mark the end</returns>
    protected IDisposable WriteGroup(Action<string> start, Action<string> end, string value)
    {
        return new GroupWrite(start, end, value);
    }

    /// <summary>
    /// Build the source string
    /// </summary>
    /// <returns>Source string</returns>
    protected string BuildSourceString()
    {
        var builder = _buffer.GetStringBuilder();

        for (var i = builder.Length - 1; i >= 0; i--)
        {
            if (char.IsWhiteSpace(builder[i]))
            {
                builder.Length = i;
            }
            else
            {
                break;
            }
        }

        return builder.ToString();
    }

    /// <summary>
    /// Returning self and all interfaces
    /// </summary>
    /// <param name="interfaceSymbol">Interface symbol</param>
    /// <returns>Alle interfaces</returns>
    protected IEnumerable<ITypeSymbol> GetInterfaces(ITypeSymbol interfaceSymbol)
    {
        yield return interfaceSymbol;

        foreach (var parenInterface in interfaceSymbol.AllInterfaces)
        {
            yield return parenInterface;
        }
    }

    /// <summary>
    /// Create the sorting key for the member
    /// </summary>
    /// <param name="symbol">Member symbol</param>
    /// <returns>Sorting key</returns>
    private protected MemberSortingKey GetMemberSortKey(ISymbol symbol)
    {
        foreach (var constructorArguments in symbol.GetAttributes()
                                                   .Where(obj => SymbolEqualityComparer.Default.Equals(obj.AttributeClass, MetaData.OrderAttribute))
                                                   .Select(obj => obj.ConstructorArguments))
        {
            if (constructorArguments.Length == 0
                || constructorArguments[0].Values.Any(obj => (GeneratorType?)(int?)obj.Value == GeneratorType.Comparable))
            {
                return new MemberSortingKey(MemberSortingType.Attribute, (long?)constructorArguments[1].Value ?? 0);
            }
        }

        return new MemberSortingKey(MemberSortingType.Location, symbol.Locations.FirstOrDefault(location => location.IsInSource)?.SourceSpan.Start ?? 0);
    }

    #endregion // Methods
}