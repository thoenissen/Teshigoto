using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;

using Teshigoto.Generators.Core.Extensions;
using Teshigoto.Generators.Equable;

namespace Teshigoto.Generators.Proxy;

/// <summary>
/// Generate to generate proxy implementations of classes
/// </summary>
public class ClassProxyGenerator : ProxyGeneratorBase
{
    #region Fields

    /// <summary>
    /// Size of the indention
    /// </summary>
    private const int IndentionSize = 4;

    /// <summary>
    /// <see cref="GeneratedCodeAttribute"/> for the generated code
    /// </summary>
    private static readonly string _generateCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{Assembly.GetExecutingAssembly().GetName().Name}\", \"{Assembly.GetExecutingAssembly().GetName().Version}\")]";

    /// <summary>
    /// Buffer for the generated code
    /// </summary>
    private StringWriter _buffer;

    /// <summary>
    /// Writer for the generated code
    /// </summary>
    private IndentedTextWriter _writer;

    #endregion // Fields

    #region Properties

    /// <summary>
    /// Symbol to generate the implementation for
    /// </summary>
    protected ITypeSymbol Symbol { get; private set; }

    /// <summary>
    /// Fully qualified name of the symbol
    /// </summary>
    protected string SymbolName { get; private set; }

    /// <summary>
    /// Interface symbol to be proxied
    /// </summary>
    protected ITypeSymbol InterfaceSymbol { get; private set; }

    /// <summary>
    /// Fully qualified name of the interface symbol
    /// </summary>
    protected string InterfaceSymbolName { get; private set; }

    #endregion // Properties

    /// <summary>
    /// Initialize the generator
    /// </summary>
    /// <param name="symbol">Symbol</param>
    /// <param name="proxyAttributeData">ProxyAttribute data</param>
    private void Initialize(ITypeSymbol symbol, AttributeData proxyAttributeData)
    {
        Symbol = symbol;
        SymbolName = Symbol.ToFullQualifiedDisplayString();

        InterfaceSymbol = proxyAttributeData.AttributeClass!.TypeArguments[0];
        InterfaceSymbolName = InterfaceSymbol.ToFullQualifiedDisplayString();

        _buffer = new StringWriter(new StringBuilder(4096));
        _writer = new IndentedTextWriter(_buffer, " ");

        WriteLine("// <auto-generated>");
        WriteLine("//     This code was generated by Teshigoto.Generators.");
        WriteLine($"//     Version: {Assembly.GetExecutingAssembly().GetName().Version}");
        WriteLine("//");
        WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
        WriteLine("// </auto-generated>");
        WriteLine();
        WriteLine("#nullable enable");
        WriteLine();
    }

    /// <summary>
    /// Write namespace
    /// </summary>
    private void WriteOpenNamespace()
    {
        foreach (var symbol in SymbolWalker.ContainingNamespaceAndTypes(Symbol)
                                           .Reverse())
        {
            if (symbol is INamespaceSymbol namespaceSymbol)
            {
                WriteNamespace(namespaceSymbol);
            }
            else
            {
                break;
            }
        }
    }

    /// <summary>
    /// Write parent types
    /// </summary>
    private void WriteOpenParentTypes()
    {
        foreach (var symbol in SymbolWalker.ContainingNamespaceAndTypes(Symbol)
                     .Reverse())
        {
            if (symbol is not INamespaceSymbol)
            {
                WriteParentSymbol(symbol);
            }
        }

        WriteDeclaredAccessibility(Symbol.DeclaredAccessibility);
        WriteParentSymbol(Symbol);
    }

    /// <summary>
    /// Write the file-scoped namespace
    /// </summary>
    /// <param name="symbol">Symbol of the namespace</param>
    private void WriteNamespace(INamespaceSymbol symbol)
    {
        var namespaceName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));

        if (string.IsNullOrEmpty(namespaceName) == false)
        {
            WriteLine($"namespace {namespaceName};");
        }
    }

    /// <summary>
    /// Write a parent type
    /// </summary>
    /// <param name="symbol">Symbol of the parent type</param>
    private void WriteParentSymbol(ISymbol symbol)
    {
        var typeDeclarationSyntax = symbol.DeclaringSyntaxReferences
                                          .Select(x => x.GetSyntax())
                                          .OfType<TypeDeclarationSyntax>()
                                          .First();

        var keyword = typeDeclarationSyntax.Kind() switch
                      {
                          SyntaxKind.ClassDeclaration => "class",
                          SyntaxKind.RecordDeclaration => "record",
                          SyntaxKind.RecordStructDeclaration => "record struct",
                          SyntaxKind.StructDeclaration => "struct",
                          var unknownKind => throw new ArgumentOutOfRangeException($"Syntax kind {unknownKind} not supported")
                      };

        var typeName = symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        WriteLine($"partial {keyword} {typeName}");
        WriteOpenBracket();
    }

    /// <summary>
    /// Write all missing closing brackets
    /// </summary>
    private void WriteCloseNamespaceAndParentType()
    {
        while (_writer.Indent > 0)
        {
            WriteCloseBracket();

            if (_writer.Indent > 0)
            {
                _writer.WriteLine();
            }
        }
    }

    /// <summary>
    /// Write the <see cref="GeneratedCodeAttribute"/>
    /// </summary>
    protected void WriteGeneratedCodeAttribute()
    {
        WriteLine(_generateCodeAttribute);
    }

    /// <summary>
    /// Write a characters (without line break) to the generated code
    /// </summary>
    /// <param name="characters">Characters</param>
    protected void Write(string characters)
    {
        _writer.Write(characters);
    }

    /// <summary>
    /// Writes an empty line to the generated code
    /// </summary>
    private void WriteLine()
    {
        var currentIndent = _writer.Indent;

        _writer.Indent = 0;
        _writer.WriteLine();
        _writer.Indent = currentIndent;
    }

    /// <summary>
    /// Writes a line to the generated code
    /// </summary>
    /// <param name="line">Line</param>
    private void WriteLine(string line)
    {
        _writer.WriteLine(line);
    }

    /// <summary>
    /// Write an opening bracket (<c>'{'</c>) and increase the indention
    /// </summary>
    protected void WriteOpenBracket()
    {
        WriteLine("{");

        _writer.Indent += IndentionSize;
    }

    /// <summary>
    /// Write a closing bracket (<c>'}'</c>) and decrease the indention
    /// </summary>
    protected void WriteCloseBracket()
    {
        _writer.Indent -= IndentionSize;

        WriteLine("}");
    }

    /// <summary>
    /// Build the source string
    /// </summary>
    /// <returns>Source string</returns>
    private string BuildSourceString()
    {
        var builder = _buffer.GetStringBuilder();

        for (var i = builder.Length - 1; i >= 0; i--)
        {
            if (char.IsWhiteSpace(builder[i]))
            {
                builder.Length = i;
            }
            else
            {
                break;
            }
        }

        return builder.ToString();
    }

    #region ProxyGeneratorBase

    /// <inheritdoc />
    public override string Generate(ITypeSymbol symbol, AttributeData proxyAttributeData)
    {
        Initialize(symbol, proxyAttributeData);

        WriteOpenNamespace();

        WriteLine();

        WriteProxyInterface();

        WriteLine();

        WriteResolver();

        WriteLine();

        WriteOpenParentTypes();

        WriteProxy();

        WriteCloseNamespaceAndParentType();

        return BuildSourceString();
    }

    /// <summary>
    /// Write _IProxy
    /// </summary>
    private void WriteProxyInterface()
    {
        WriteLine("#region _IProxy");
        WriteLine();
        WriteGeneratedCodeAttribute();
        WriteLine("file interface _IProxy");
        WriteOpenBracket();
        WriteLine("/// <summary>");
        WriteLine("/// Implementation");
        WriteLine("/// </summary>");
        Write("public ");
        Write(InterfaceSymbolName);
        WriteLine(" Implementation { get; set; }");
        WriteCloseBracket();
        WriteLine();
        WriteLine("#endregion // IProxy");
    }

    /// <summary>
    /// Writes the declared accessibility
    /// </summary>
    /// <param name="accessibility">Accessibility</param>
    protected void WriteDeclaredAccessibility(Accessibility accessibility)
    {
        var accessibilityString = accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.Private => "private",
            _ => throw new ArgumentOutOfRangeException($"Accessibility {accessibility} not supported")
        };

        Write(accessibilityString);
        Write(" ");
    }

    /// <summary>
    /// Write _Resolver
    /// </summary>
    private void WriteResolver()
    {
        WriteLine("#region _Resolver");
        WriteLine();
        WriteLine("/// <summary>");
        WriteLine("/// Temporary implementation to intercept the calls to resolve the implementation object");
        WriteLine("/// </summary>");
        WriteGeneratedCodeAttribute();
        Write("file class _Resolver : ");
        WriteLine(InterfaceSymbolName);
        WriteOpenBracket();
        WriteLine("#region Fields");
        WriteLine();
        WriteLine("/// <summary>");
        WriteLine("/// Proxy assigned to the resolver");
        WriteLine("/// </summary>");
        WriteLine("private _IProxy _proxy;");
        WriteLine();
        WriteLine("#endregion // Fields");
        WriteLine();
        WriteLine("#region Constructor");
        WriteLine();
        WriteLine("/// <summary>");
        WriteLine("/// Constructor");
        WriteLine("/// </summary>");
        WriteLine("/// <param name=\"proxy\">Proxy object</param>");
        WriteLine("public _Resolver(_IProxy proxy)");
        WriteOpenBracket();
        WriteLine("_proxy = proxy;");
        WriteCloseBracket();
        WriteLine();
        WriteLine("#endregion // Constructor");
        WriteLine();
        WriteLine("#region Methods");
        WriteLine();
        WriteLine("/// <summary>");
        WriteLine("/// Resolving the implementation object");
        WriteLine("/// </summary>");
        WriteLine("private void Resolve()");
        WriteOpenBracket();
        WriteLine("lock (this)");
        WriteOpenBracket();
        WriteLine("if (_proxy.Implementation == this)");
        WriteOpenBracket();
        Write("_proxy.Implementation = new ");
        Write(SymbolName);
        WriteLine("();");
        WriteCloseBracket();
        WriteCloseBracket();
        WriteCloseBracket();
        WriteLine();
        WriteLine("#endregion // Methods");
        WriteMembers(true);
        WriteCloseBracket();
        WriteLine();
        WriteLine("#endregion // _Resolver");
    }

    /// <summary>
    /// Write Proxy
    /// </summary>
    private void WriteProxy()
    {
        WriteLine("/// <summary>");
        WriteLine($"/// Proxy of <see cref=\"{SymbolName}\"/> which implements <see cref=\"{InterfaceSymbolName}\"/>");
        WriteLine("/// </summary>");
        WriteGeneratedCodeAttribute();
        WriteDeclaredAccessibility(Symbol.DeclaredAccessibility);
        Write("class Proxy : ");
        Write(InterfaceSymbolName);
        WriteLine(",");
        WriteLine("                       _IProxy");
        WriteOpenBracket();
        WriteLine("#region Fields");
        WriteLine();
        WriteLine("/// <summary>");
        WriteLine($"/// Implementation of <see cref=\"{InterfaceSymbolName}\"/>");
        WriteLine("/// </summary>");
        WriteLine($"private {InterfaceSymbolName} _implementation;");
        WriteLine();
        WriteLine("#endregion // Fields");
        WriteLine();
        WriteLine("#region Constructor");
        WriteLine();
        WriteLine("/// <summary>");
        WriteLine("/// Constructor");
        WriteLine("/// </summary>");
        WriteLine("public Proxy()");
        WriteOpenBracket();
        WriteLine("_implementation = new _Resolver(this);");
        WriteCloseBracket();
        WriteLine();
        WriteLine("#endregion // Constructor");
        WriteLine();
        WriteLine("#region _IProxy");
        WriteLine();
        WriteLine("/// <inheritdoc />");
        Write(InterfaceSymbolName);
        WriteLine(" _IProxy.Implementation");
        WriteLine("{");
        WriteLine("    get => _implementation;");
        WriteLine("    set => _implementation = value;");
        WriteLine("}");
        WriteLine();
        WriteLine("#endregion // _IProxy");
        WriteMembers(false);
        WriteCloseBracket();
    }

    /// <summary>
    /// Writer member implementation
    /// </summary>
    /// <param name="isResolver">Are the member of the resolver be generated?</param>
    private void WriteMembers(bool isResolver)
    {
        foreach (var interfaceSymbol in GetInterfaces(InterfaceSymbol))
        {
            var interfaceSymbolName = interfaceSymbol.ToFullQualifiedDisplayString();

            WriteLine();
            Write("#region ");
            WriteLine(interfaceSymbolName);
            WriteLine();

            foreach (var member in interfaceSymbol.GetMembers())
            {
                switch (member)
                {
                    case IPropertySymbol propertySymbol:
                        {
                            WriteLine("/// <inheritdoc />");
                            Write(propertySymbol.Type.ToFullQualifiedDisplayString());
                            Write(" ");
                            Write(interfaceSymbolName);
                            Write(".");
                            WriteLine(propertySymbol.Name);
                            WriteOpenBracket();

                            if (propertySymbol.GetMethod != null)
                            {
                                if (isResolver)
                                {
                                    WriteLine("get");
                                    WriteOpenBracket();
                                    WriteLine("Resolve();");
                                    WriteLine();
                                    Write("return _proxy.Implementation.");
                                    Write(propertySymbol.Name);
                                    WriteLine(";");
                                    WriteCloseBracket();
                                }
                                else
                                {
                                    Write("get => _implementation.");
                                    Write(propertySymbol.Name);
                                    WriteLine(";");
                                }
                            }

                            if (propertySymbol.SetMethod != null)
                            {
                                if (isResolver)
                                {
                                    WriteLine("set");
                                    WriteOpenBracket();
                                    WriteLine("Resolve();");
                                    WriteLine();
                                    Write("_proxy.Implementation.");
                                    Write(propertySymbol.Name);
                                    WriteLine(" = value;");
                                    WriteCloseBracket();
                                }
                                else
                                {
                                    Write("set => _implementation.");
                                    Write(propertySymbol.Name);
                                    WriteLine(" = value;");
                                }
                            }

                            WriteCloseBracket();
                        }
                        break;

                    case IMethodSymbol methodSymbol:
                        {
                            if (methodSymbol.MethodKind != MethodKind.Ordinary)
                            {
                                continue;
                            }

                            WriteLine("/// <inheritdoc />");
                            Write(methodSymbol.ReturnType.ToFullQualifiedDisplayString());
                            Write(" ");
                            Write(interfaceSymbolName);
                            Write(".");
                            Write(methodSymbol.Name);
                            Write("(");

                            void WriteParameter(IParameterSymbol parameter, bool withType)
                            {
                                var refKind = parameter.RefKind switch
                                {
                                    RefKind.None => string.Empty,
                                    RefKind.Ref => "ref ",
                                    RefKind.Out => "out ",
                                    RefKind.In => "in ",
                                    RefKind.RefReadOnlyParameter => "ref readonly ",
                                    _ => $"#error The given ref type '{parameter.RefKind}' is not supported\r\n"
                                };
                                Write(refKind);

                                if (withType)
                                {
                                    Write(parameter.Type.ToFullQualifiedDisplayString());
                                    Write(" ");
                                }

                                Write(parameter.Name);
                            }

                            if (methodSymbol.Parameters.Length > 0)
                            {
                                WriteParameter(methodSymbol.Parameters[0], true);

                                foreach (var parameter in methodSymbol.Parameters.Skip(1))
                                {
                                    Write(", ");
                                    WriteParameter(parameter, true);
                                }
                            }

                            WriteLine(")");
                            WriteOpenBracket();

                            if (isResolver)
                            {
                                WriteLine("Resolve();");
                                WriteLine();
                            }

                            if (methodSymbol.ReturnsVoid == false)
                            {
                                Write("return ");
                            }

                            Write(isResolver ? "_proxy.Implementation." : "_implementation.");

                            Write(methodSymbol.Name);
                            Write("(");

                            if (methodSymbol.Parameters.Length > 0)
                            {
                                WriteParameter(methodSymbol.Parameters[0], false);

                                foreach (var parameter in methodSymbol.Parameters.Skip(1))
                                {
                                    Write(", ");
                                    WriteParameter(parameter, false);
                                }
                            }

                            WriteLine(");");
                            WriteCloseBracket();
                        }
                        break;

                    case IEventSymbol eventSymbol:
                        {
                            WriteLine("/// <inheritdoc />");
                            Write("event ");
                            Write(eventSymbol.Type.ToFullQualifiedDisplayString());
                            Write(" ");
                            Write(interfaceSymbolName);
                            Write(".");
                            WriteLine(eventSymbol.Name);
                            WriteOpenBracket();

                            if (isResolver)
                            {
                                WriteLine("add");
                                WriteOpenBracket();
                                WriteLine("Resolve();");
                                WriteLine();
                                Write("_proxy.Implementation.");
                                Write(eventSymbol.Name);
                                WriteLine(" += value;");
                                WriteCloseBracket();
                            }
                            else
                            {
                                Write("add => _implementation.");
                                Write(eventSymbol.Name);
                                WriteLine(" += value;");
                            }

                            if (isResolver)
                            {
                                WriteLine("remove");
                                WriteOpenBracket();
                                WriteLine("Resolve();");
                                WriteLine();
                                Write("_proxy.Implementation.");
                                Write(eventSymbol.Name);
                                WriteLine(" += value;");
                                WriteCloseBracket();
                            }
                            else
                            {
                                Write("remove => _implementation.");
                                Write(eventSymbol.Name);
                                WriteLine(" += value;");
                            }

                            WriteCloseBracket();
                        }
                        break;

                    default:
                        WriteLine($"#error Member {member.Name} is not supported");
                        break;
                }

                WriteLine();
            }

            Write("#endregion // ");
            WriteLine(interfaceSymbolName);
        }
    }

    /// <summary>
    /// Returning self and all interfaces
    /// </summary>
    /// <param name="interfaceSymbol">Interface symbol</param>
    /// <returns>Alle interfaces</returns>
    private IEnumerable<ITypeSymbol> GetInterfaces(ITypeSymbol interfaceSymbol)
    {
        yield return interfaceSymbol;

        foreach (var parenInterface in interfaceSymbol.AllInterfaces)
        {
            yield return parenInterface;
        }
    }

    #endregion // ProxyGeneratorBase
}